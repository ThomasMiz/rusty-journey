# Cargo and Crates.io
This markdown document follows [the rust book's chapter about Cargo and Crates.io](https://doc.rust-lang.org/book/ch14-00-more-about-cargo.html).

## Cargo profiles
By default, cargo has two main profiles: `dev` and `release`, which are used when you run `cargo build` and `cargo build --release` respectively (or `cargo run`).

These profiles have default settings for when you haven't specified any `[profile.*]` sections in `Cargo.toml`. One example is `opt-level`, or _optimization level_, which ranges from 0 to 3 and specifies how much the Rust compiler will try to optimize your code (at the cost of extra compile time). These are the default implicit values:

```toml
[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
```

## Documentation
You can add in-code documentation by using three slashes `///`. This documentation style supports markdown syntax:

```rs
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```

This documentation is easily converted to HTML by running `cargo doc`! This uses the `rustdoc` command behind the scenes. We can open this documentation as html with `cargo doc --open`.

Crate authors commonly document their functions with three sections:
- **Panics**: The scenarios in which the function could panic
- **Errors**: If the function returns a `Result`, describes all the errors that could occur and under which conditions
- **Safety**: If the function is unsafe to call, an explanation of why and how to properly use it.

### Documentation Tests
Example code blocks in your documentation can be run as tests, which is done with `cargo test`, and will appear in the `Doc.tests` section of the output. This avoids old examples that don't work because the code has changed since the documentation was written.

### Documenting the crate
Using `///` will document the item next to the comment. If instead we use `//!`, we will document the item that _contains_ the comment instead. This is typically used to document the crate itself, by adding to _src/lib.rs_ something like this:

```rs
//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
```

### Structuring your public API
Your crate's code might be structured nicely for you, who had to write that library, but that structure might not make as much sense for someone who is trying to use said library.

For example, a user might want to use a type `UsefulType`, which you have at `my_crate::some_module::another_module::UsefulType`, but if this type is very common and used throughout the library's interface, then it might make more sense to just call it `my_crate::UsefulType`.

If your crate's internal organization doesn't make sense as a public API, you can easily re-export your items with a friendlier public API! This is done with `pub use`, which takes items available in one location and exports them as public, making them available to other locations. In the previous example, you'd add to _src/lib.rs_ an `pub use self::some_module::another_module::UsefulType;`.

The items re-exported will appear in the html documentation generated by `cargo doc` in a separate _Re-exports_ section. Note that this does not stop users from accessing `UsefulType` with the long path.

## Publishing a crate
Check out the chapter on [The Rust Book](https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#setting-up-a-cratesio-account) for more on this.

You'll need to add metadata to your crate by going to your _Cargo.toml_ file, into the `[package]` section, and adding a name and license:

```toml
[package]
name = "some_interesting_name"
version = "1.0.0"
edition = "2021"
description = "A crate where there is something interesting"
license = "MIT"
```

You need to log in with your crates.io access token using `cargo login <token>`, and then you can publish a crate using `cargo publish`.

You can't delete a crate or one of its versions, but you can _yank_ it to prevent future projects from adding it as a dependency. This is used when an author finds a critical issue with their crate. This is done with `cargo yank --vers 1.0.0`. A yank can be undone with `cargo yank --vers 1.0.0 --undo`.

A yank does not delete anything, it just stops future projects from using it. If you, for example, accidentally upload secrets with a crate, yanking it will not help. You must reset those secrets immediately.

## Cargo Workspaces
A workspace is a set of packages that share the same _Cargo.lock_ and output directory. This is useful when we are developing multiple crates that depend on each other.

If each one were a separate project outside a workspace, each crate would have to also compile all other crates it depends on to generate its output. This process is simplified, as all crates are simply compiled together.

Create a workspace by making a new folder, then adding a _Cargo.toml_ file with something like this:
```toml
[workspace]

members = [
    "some_project",
    "some_dependency",
]
```

Then create in that same folder the two projects, with `cargo new some_project` and `cargo new some_dependency --lib`.

Then _some_project_ can add _some_dependency_ as a dependency by adding to its _Cargo.toml_:
```toml
[dependencies]
some_dependency = { path = "../some_dependency" }
```

Since a workspace might have multiple binary crates, you can tell cargo which one to run by using `cargo run -p <crate_name>`.

If multiple crates in the workspace depend on the same external crate, then since they share a _Cargo.toml_ they will always end up using the same version of that external crate together, therefore ensuring compatibility.

Running `cargo test` will run tests for all crates in the workspace. If you want to run tests for a particular crate, you can use `cargo test -p <crate_name>`.

## Binary crates with `cargo install`
You can install and use binary crates locally. This is intended to be a convenient way to install tools created by others and shared through [crates.io](https://crates.io).

Binary crates are installed into the Rust installation's root's _bin_ folder, probably at _~/.cargo/bin_.

Install example: `cargo install ripgrep`, at the end of the install we'll see a line indicating the name of the executable, in this case it's `rg`. Running `rg --help` now works!

We can also uninstall this with `cargo uninstall ripgrep`.

## Extending Cargo
If a binary in your _PATH_ environment variable is named `cargo-something`, then you can run it as if it were a cargo sub-command with `cargo something`. Custom commands like these are also listed when you run `cargo --list`
